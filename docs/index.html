<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>binarylang</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">binarylang</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="parser-options_toc" href="#parser-options">Parser options</a></li>
<li><a class="reference" id="parser-parameters_toc" href="#parser-parameters">Parser parameters</a></li>
<li><a class="reference" id="dsl_toc" href="#dsl">DSL</a></li>
<ul class="simple"><li><a class="reference" id="dsl-type_toc" href="#dsl-type">Type</a></li>
<li><a class="reference" id="dsl-value_toc" href="#dsl-value">Value</a></li>
<li><a class="reference" id="dsl-alignment_toc" href="#dsl-alignment">Alignment</a></li>
<li><a class="reference" id="dsl-assertion_toc" href="#dsl-assertion">Assertion</a></li>
<li><a class="reference" id="dsl-complex-types_toc" href="#dsl-complex-types">Complex types</a></li>
<li><a class="reference" id="dsl-repetition_toc" href="#dsl-repetition">Repetition</a></li>
<li><a class="reference" id="dsl-substreams_toc" href="#dsl-substreams">Substreams</a></li>
<li><a class="reference" id="dsl-strings_toc" href="#dsl-strings">Strings</a></li>
<li><a class="reference" id="dsl-custom-parser-api_toc" href="#dsl-custom-parser-api">Custom parser API</a></li>
<li><a class="reference" id="dsl-operations-plugins_toc" href="#dsl-operations-plugins">Operations (plugins)</a></li>
<li><a class="reference" id="dsl-special-notes_toc" href="#dsl-special-notes">Special notes</a></li>
</ul><li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#MagicError"
    title="MagicError = object of Defect">MagicError</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#17" id="67">Macros</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#typeGetter.m%2Ctyped"
    title="typeGetter(body: typed): untyped">typeGetter</a></li>
  <li><a class="reference" href="#createParser.m%2Cuntyped%2Cvarargs%5Buntyped%5D"
    title="createParser(name: untyped; rest: varargs[untyped]): untyped">createParser</a></li>
  <li><a class="reference" href="#createVariantParser.m%2Cuntyped%2Cuntyped%2Cuntyped%2Cvarargs%5Buntyped%5D"
    title="createVariantParser(name, typ, disc: untyped; rest: varargs[untyped]): untyped">createVariantParser</a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><p>BinaryLang is a DSL for creating binary parsers/encoders.</p>
<p>It exports two macros:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">createParser</span></tt> which is used for <em>product types</em> (tuples)</li>
<li><tt class="docutils literal"><span class="pre">createVariantParser</span></tt> which is used for <em>sum types</em> (object variants)</li>
</ul>
<p>Both of these macro generate a <tt class="docutils literal"><span class="pre">tuple[get: proc, put: proc]</span></tt>:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">get</span></tt> returns a tuple with each parsed field</li>
<li><tt class="docutils literal"><span class="pre">put</span></tt> writes a compatible tuple to a stream</li>
</ul>
<p><tt class="docutils literal"><span class="pre">createVariantParser</span></tt> additionally creates an object variant type.</p>
<p><tt class="docutils literal"><span class="pre">createParser</span></tt> accepts 4 kind of things:</p>
<ul class="simple"><li>Name of the parser tuple</li>
<li>Parser options (optional)</li>
<li>Parser parameters (optional)</li>
<li>Block with DSL statements</li>
</ul>
<p><tt class="docutils literal"><span class="pre">createVariantParser</span></tt> accepts 6 kind of things:</p>
<ul class="simple"><li>Name of the parser tuple</li>
<li>Name of the object variant type</li>
<li>Discriminator</li>
<li>Parser options (optional)</li>
<li>Parser parameters (optional)</li>
<li>Block with DSL statements</li>
</ul>

<h1><a class="toc-backref" id="parser-options" href="#parser-options">Parser options</a></h1><p>Each specified option must be in the form <tt class="docutils literal"><span class="pre">option = value</span></tt>:</p>
<ul class="simple"><li><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">endian</span></tt>: sets the default byte endianness for the whole parser</dt>
<dd><ul class="simple"><li><em>default</em>: big endian</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt>: <strong>big</strong> endian</li>
<li><tt class="docutils literal"><span class="pre">l</span></tt>: <strong>little</strong> endian</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">bitEndian</span></tt>: sets the default bit endianness for the whole parser</dt>
<dd><ul class="simple"><li><em>default</em>: left -&gt; right</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt>: left -&gt; right (<strong>normal</strong>)</li>
<li><tt class="docutils literal"><span class="pre">r</span></tt>: left &lt;- right (<strong>reverse</strong>)</li>
</ul>
</dd>
</dl>
</li>
</ul>

<h1><a class="toc-backref" id="parser-parameters" href="#parser-parameters">Parser parameters</a></h1><p>Each parameter must be in the form <tt class="docutils literal"><span class="pre">symbol: type</span></tt>. The generated <tt class="docutils literal"><span class="pre">get</span></tt>/<tt class="docutils literal"><span class="pre">put</span></tt> procs will then have this additional parameter appended.</p>

<h1><a class="toc-backref" id="dsl" href="#dsl">DSL</a></h1><p>Each statement corresponds to 1 field. The general syntax is:</p>
<pre class="listing"><span class="Keyword">Type</span> <span class="Punctuation">{</span><span class="Identifier">Operations</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Value</span></pre><p>where <tt class="docutils literal"><span class="pre">{Operations}</span></tt> is optional and refers to a plugin system (see below).</p>

<h2><a class="toc-backref" id="dsl-type" href="#dsl-type">Type</a></h2><p>The <strong>kind</strong>, <strong>endianness</strong> and <strong>size</strong> are encoded in a identifier made up of:</p>
<ul class="simple"><li><dl class="docutils"><dt>1 optional letter specifying the kind:</dt>
<dd><ul class="simple"><li><em>default</em>: signed integer</li>
<li><tt class="docutils literal"><span class="pre">u</span></tt>: <strong>unsigned</strong> integer</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt>: <strong>float</strong></li>
<li><tt class="docutils literal"><span class="pre">s</span></tt>: <strong>string</strong></li>
<li><tt class="docutils literal"><span class="pre">*</span></tt>: complex (see below)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt>1 optional letter specifying byte endianness:</dt>
<dd><ul class="simple"><li><em>default</em>: big endian</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt>: <strong>big</strong> endian</li>
<li><tt class="docutils literal"><span class="pre">l</span></tt>: <strong>little</strong> endian</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt>1 optional letter specifying bit endianness:</dt>
<dd><ul class="simple"><li><em>default</em>: left -&gt; right</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt>: left -&gt; right (<strong>normal</strong>)</li>
<li><tt class="docutils literal"><span class="pre">r</span></tt>: left &lt;- right (<strong>reverse</strong>)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt>1 number specifying size in <strong>bits</strong>:</dt>
<dd><ul class="simple"><li>for a string it refers to the size of each individual character and defaults to <tt class="docutils literal"><span class="pre">8</span></tt></li>
<li>for an integer the allowed values are <tt class="docutils literal"><span class="pre">1 .. 64</span></tt></li>
<li>for a float the allowed values are <tt class="docutils literal"><span class="pre">32</span></tt> and <tt class="docutils literal"><span class="pre">64</span></tt></li>
<li>for a custom it can't be used (but you can use a substream, see below)</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>You can order options however you want, but size must come last (e.g. <tt class="docutils literal"><span class="pre">lru16</span></tt> and <tt class="docutils literal"><span class="pre">url16</span></tt> are valid but not <tt class="docutils literal"><span class="pre">16lru</span></tt>).</p>

<h2><a class="toc-backref" id="dsl-value" href="#dsl-value">Value</a></h2><p>This section includes the following features (only name is mandatory):</p>
<ul class="simple"><li>name</li>
<li>repetition</li>
<li>assertion</li>
</ul>
<p>If you don't <em>really</em> want a name, you can discard the symbol by using <tt class="docutils literal"><span class="pre">_</span></tt> in its place:</p>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">_</span></pre>
<h2><a class="toc-backref" id="dsl-alignment" href="#dsl-alignment">Alignment</a></h2><p>If any of the following is violated, BinaryLang should generate an exception:</p>
<ul class="simple"><li>Byte endianness can only be used with byte-multiple integers</li>
<li>Bit endianness must be uniform between <strong>byte boundaries</strong></li>
<li>Spec must finish on a byte boundary</li>
</ul>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">,</span> <span class="Identifier">bitEndian</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">b9</span><span class="Punctuation">:</span> <span class="Identifier">a</span> <span class="Comment"># error: cannot apply byte endianness</span>
  <span class="Identifier">r6</span><span class="Punctuation">:</span> <span class="Identifier">b</span> <span class="Comment"># error: shares bits with previous byte</span>
  <span class="DecNumber">10</span><span class="Punctuation">:</span> <span class="Identifier">c</span> <span class="Comment"># error: spec does not finish on a byte boundary</span></pre><p>Moreover, unaligned reads for strings are not supported:</p>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">6</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">y</span> <span class="Comment"># invalid, generates an exception</span></pre>
<h2><a class="toc-backref" id="dsl-assertion" href="#dsl-assertion">Assertion</a></h2><p>Use <tt class="docutils literal"><span class="pre">= expr</span></tt> for producing an exception if the parsed value doesn't match <tt class="docutils literal"><span class="pre">expr</span></tt>:</p>
<pre class="listing"><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;BinaryLang is awesome&quot;</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">]</span></pre><p>Assertion can also be used in a special manner to terminate the previous field if it's a <strong>string</strong> or a <strong>sequence indicated as magic-terminated</strong>. This is discussed in later sections.</p>

<h2><a class="toc-backref" id="dsl-complex-types" href="#dsl-complex-types">Complex types</a></h2><p>Instead of the described identifier for specifying <tt class="docutils literal"><span class="pre">Type</span></tt>, you can call a previously defined parser by using <tt class="docutils literal"><span class="pre">*</span></tt> followed by the name of the parser. If your parser is parametric you must pass arguments to it with standard call syntax.</p>
<p>Example:</p>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">inner</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">a</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">b</span>

<span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">innerWithArgs</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">int32</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">a</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">]</span>

<span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">outer</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Operator">*</span><span class="Identifier">inner</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="Operator">*</span><span class="Identifier">innerWithArgs</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="dsl-repetition" href="#dsl-repetition">Repetition</a></h2><p>There are 3 ways to produce a <tt class="docutils literal"><span class="pre">seq</span></tt> of your <tt class="docutils literal"><span class="pre">Type</span></tt>:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">for</span></tt>: append <tt class="docutils literal"><span class="pre">[expr]</span></tt> to the name for repeating <tt class="docutils literal"><span class="pre">expr</span></tt> times</li>
<li><tt class="docutils literal"><span class="pre">until</span></tt>: append <tt class="docutils literal"><span class="pre">{expr}</span></tt> to the name for repeating until <tt class="docutils literal"><span class="pre">expr</span></tt> is evaluated to <tt class="docutils literal"><span class="pre">true</span></tt></li>
<li><tt class="docutils literal"><span class="pre">magic</span></tt>: enclose name with <tt class="docutils literal"><span class="pre">{}</span></tt> and use assertion with your <strong>next</strong> field</li>
</ul>
<pre class="listing"><span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Comment"># reads 5 8-bit integers</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">{</span><span class="Identifier">e</span> <span class="Operator">==</span> <span class="DecNumber">103</span> <span class="Keyword">or</span> <span class="Identifier">i</span> <span class="Operator">&gt;</span> <span class="DecNumber">9</span><span class="Punctuation">}</span> <span class="Comment"># reads until it finds the value 103 or completes 10th iteration</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">c</span><span class="Punctuation">}</span> <span class="Comment"># reads 8-bit integers until next field is matches</span>
<span class="DecNumber">16</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="HexNumber">0xABCD</span>
<span class="Identifier">u8</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">d</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">}</span> <span class="Comment"># reads byte sequences each of length 5 until next field matches</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="StringLit">&quot;END&quot;</span></pre><p>Also, the following symbols are defined implicitly:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">i</span></tt>: current iteration index</li>
<li><tt class="docutils literal"><span class="pre">e</span></tt>: last element read</li>
</ul>
<p>These can be leveraged even in other expressions than the expression for repetition itself; for instance you can use them to parameterize a parser:</p>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">inner</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">]</span>
<span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">outer</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">amount</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">sizes</span><span class="Punctuation">[</span><span class="Identifier">amount</span><span class="Punctuation">]</span>
  <span class="Operator">*</span><span class="Identifier">inner</span><span class="Punctuation">(</span><span class="Identifier">sizes</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">complex</span><span class="Punctuation">[</span><span class="Identifier">amount</span><span class="Punctuation">]</span></pre><p>With the above trick you can get a sequence of variable-length sequences.</p>
<p>Due to current limitations of the underlying bitstream implementation, to perform magic, your stream must be aligned and all the reads involved must also be aligned. This will be fixed in the future.</p>

<h2><a class="toc-backref" id="dsl-substreams" href="#dsl-substreams">Substreams</a></h2><p>Call syntax forces the creation of a substream:</p>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">aux</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">]</span>
<span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">limit</span> <span class="Operator">=</span> <span class="DecNumber">8</span>
  <span class="Operator">*</span><span class="Identifier">aux</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">fixed</span><span class="Punctuation">(</span><span class="Identifier">limit</span><span class="Punctuation">)</span></pre><p>In the above example, <tt class="docutils literal"><span class="pre">limit</span></tt> bytes (8 in this case) will be read from the main <tt class="docutils literal"><span class="pre">BitStream</span></tt>. Then, a substream will be created out of them, which will then be used as the stream for parsing <tt class="docutils literal"><span class="pre">fixed</span></tt>. Since <tt class="docutils literal"><span class="pre">fixed</span></tt> will only use 4 of them, the remaining 4 will effectively be discarded.</p>
<p>Note that unlike in <tt class="docutils literal"><span class="pre">Type</span></tt>, here size is counted in bytes. It is implied that you cannot create a substream if your bitstream is unaligned.</p>
<p>This feature is <strong>not implemented for repetition</strong> because it would increase complexity with little benefits. The following syntax is <strong>invalid</strong> and instead you should use the technique with the auxiliary complex type shown above:</p>
<pre class="listing"><span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">u8</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># does substream refer to each individual element or the whole sequence?</span></pre>
<h2><a class="toc-backref" id="dsl-strings" href="#dsl-strings">Strings</a></h2><p>Strings are special because they don't have a fixed size. Therefore, you must provide enough information regarding their termination. This can be achieved with one of the following:</p>
<ul class="simple"><li>Use of substream</li>
<li>Assertion</li>
<li>Magic</li>
</ul>
<pre class="listing"><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">a</span> <span class="Comment"># null/eos-terminated (because next field doesn't use assertion)</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># reads a string from a substream of 5 bytes until null/eos</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="StringLit">&quot;ABC&quot;</span> <span class="Comment"># reads a string of length 3 that must match &quot;ABC&quot;</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">d</span> <span class="Comment"># reads a string until next field matches</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="StringLit">&quot;MAGIC&quot;</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">e</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Comment"># reads 5 null-terminated strings</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">f</span><span class="Punctuation">}</span> <span class="Comment"># reads null-terminated strings until next field matches</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">term</span> <span class="Operator">=</span> <span class="HexNumber">0xff</span> <span class="Comment"># terminator of the above sequence</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">g</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">}</span> <span class="Comment"># sequence of 5-length sequences of null-terminated strings</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="StringLit">&quot;END_NESTED&quot;</span></pre><p>Rules:</p>
<ul class="simple"><li>Strings are null/eos-terminated unless assertion is used on the same field <strong>or</strong> on the next field</li>
<li>When using repetition, each string element is null-terminated</li>
</ul>

<h2><a class="toc-backref" id="dsl-custom-parser-api" href="#dsl-custom-parser-api">Custom parser API</a></h2><p>Since a BinaryLang parser is just a <tt class="docutils literal"><span class="pre">tuple[get: proc, set: proc]</span></tt>, you can write parsers by hand that are compatible with the DSL. Just be sure that <tt class="docutils literal"><span class="pre">get</span></tt> and <tt class="docutils literal"><span class="pre">set</span></tt> have proper signatures:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">get</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SomeType</span>
<span class="Keyword">proc</span> <span class="Identifier">put</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Identifier">SomeType</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">parser</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">get</span><span class="Punctuation">:</span> <span class="Identifier">get</span><span class="Punctuation">,</span> <span class="Identifier">put</span><span class="Punctuation">:</span> <span class="Identifier">put</span><span class="Punctuation">)</span></pre><p>If you want your custom parser to be parametric, simply append more parameters to your procs. These extra parameters must be identical and in the same order in the two procs.</p>
<p>Example:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">get</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SomeType</span>
<span class="Keyword">proc</span> <span class="Identifier">put</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Identifier">SomeType</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">parser</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">get</span><span class="Punctuation">:</span> <span class="Identifier">get</span><span class="Punctuation">,</span> <span class="Identifier">put</span><span class="Punctuation">:</span> <span class="Identifier">put</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="dsl-operations-plugins" href="#dsl-operations-plugins">Operations (plugins)</a></h2><p>The syntax for applying an operation on a field is the following:</p>
<pre class="listing"><span class="Keyword">Type</span> <span class="Punctuation">{</span><span class="Identifier">plugin</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Value</span></pre><p>An operation is nothing more than a pair of templates which follow a specific pattern:</p>
<ul class="simple"><li>The names of the templates <strong>must</strong> follow the pattern: [name of operation] + <tt class="docutils literal"><span class="pre">get</span></tt>/<tt class="docutils literal"><span class="pre">put</span></tt></li>
<li><dl class="docutils"><dt>They must have exactly 3 untyped parameters (you can name them as you wish):</dt>
<dd><ul class="simple"><li><strong>parameter #1</strong>: the field you operate on</li>
<li><strong>parameter #2</strong>: parsing/encoding statements</li>
<li><strong>parameter #3</strong>: expression provided</li>
</ul>
</dd>
</dl>
</li>
</ul>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">increaseGet</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">,</span> <span class="Identifier">parse</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parse</span>
  <span class="Identifier">field</span> <span class="Operator">+=</span> <span class="Identifier">num</span>
<span class="Keyword">template</span> <span class="Identifier">increasePut</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">,</span> <span class="Identifier">encode</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">field</span> <span class="Operator">-=</span> <span class="Identifier">num</span>
  <span class="Identifier">encode</span>
<span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">64</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="DecNumber">16</span> <span class="Punctuation">{</span><span class="Identifier">increase</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">y</span></pre><p>Note that in <tt class="docutils literal"><span class="pre">increaseGet</span></tt> we parse <em>before</em> operating on <tt class="docutils literal"><span class="pre">field</span></tt>, while in <tt class="docutils literal"><span class="pre">increasePut</span></tt> we encode <em>after</em> operating on <tt class="docutils literal"><span class="pre">field</span></tt>.</p>
<p>You can also apply more than one operations on one field, in which case they are chained in the specified order, and there are some special rules:</p>
<ul class="simple"><li>only the <strong>first</strong> operation has 3 parameters as described above</li>
<li>the rest <strong>must</strong> not have a parameter for parsing/encoding, since this is only done once</li>
</ul>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">condGet</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">,</span> <span class="Identifier">parse</span><span class="Punctuation">,</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Identifier">parse</span>
<span class="Keyword">template</span> <span class="Identifier">condPut</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">,</span> <span class="Identifier">encode</span><span class="Punctuation">,</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Identifier">encode</span>
<span class="Keyword">template</span> <span class="Identifier">increaseGet</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">field</span> <span class="Operator">+=</span> <span class="Identifier">num</span>
<span class="Keyword">template</span> <span class="Identifier">increasePut</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">field</span> <span class="Operator">-=</span> <span class="Identifier">num</span>
<span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">shouldParse</span>
  <span class="DecNumber">64</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="DecNumber">16</span> <span class="Punctuation">{</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">shouldParse</span><span class="Operator">.</span><span class="Identifier">bool</span><span class="Punctuation">,</span> <span class="Identifier">increase</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">y</span></pre><p>Note that there is one limitation: Operations only alter the <em>value</em> of the field and cannot alter the <em>type</em>. If you need a different type, then you need to resort to a custom parser.</p>

<h2><a class="toc-backref" id="dsl-special-notes" href="#dsl-special-notes">Special notes</a></h2><ul class="simple"><li><dl class="docutils"><dt>Nim expressions may contain:</dt>
<dd><ul class="simple"><li>a previously defined field</li>
<li>a parser parameter</li>
<li>the <tt class="docutils literal"><span class="pre">e</span></tt> symbol for getting the last element read in a repetition</li>
<li>the <tt class="docutils literal"><span class="pre">i</span></tt> symbol for current index in a repetition</li>
<li>the <tt class="docutils literal"><span class="pre">s</span></tt> symbol for accessing the bitstream</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>These might conflict with your variables or fields, so you shouldn't use them for something else.</p>
<p>BinaryLang is a complete rewrite of <a class="reference external" href="https://github.com/PMunch/binaryparse">binaryparse</a> by <a class="reference external" href="https://github.com/PMunch">PMunch</a> (special thanks). The codebase is a lot cleaner and the bit fiddling has been extracted to a separate library (<a class="reference external" href="https://github.com/sealmove/bitstreams">bitstreams</a>) which BinaryLang depends on. Moreover, a lot of features have been added, including a plugin system for user-defined language extensions!</p>
</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<a id="MagicError"></a>
<dt><pre><a href="binarylang.html#MagicError"><span class="Identifier">MagicError</span></a> <span class="Other">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Defect</span>
  </pre></dt>
<dd>

Error raised from the parser procedure when a magic sequence is not matching the specified value.

</dd>

</dl></div>
<div class="section" id="17">
<h1><a class="toc-backref" href="#17">Macros</a></h1>
<dl class="item">
<a id="typeGetter.m,typed"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#typeGetter.m%2Ctyped"><span class="Identifier">typeGetter</span></a><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Helper macro to get the return type of custom parsers

</dd>
<a id="createParser.m,untyped,varargs[untyped]"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#createParser.m%2Cuntyped%2Cvarargs%5Buntyped%5D"><span class="Identifier">createParser</span></a><span class="Other">(</span><span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">rest</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">untyped</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

The main macro in this module. It takes the <tt class="docutils literal"><span class="pre">name</span></tt> of the tuple to create along with a block on the format described above and creates a reader and a writer for it. The output is a tuple with <tt class="docutils literal"><span class="pre">name</span></tt> that has two fields <tt class="docutils literal"><span class="pre">get</span></tt> and <tt class="docutils literal"><span class="pre">put</span></tt>. Get is on the form <tt class="docutils literal"><span class="pre">proc (bs: BitStream): tuple[&lt;fields&gt;]</span></tt> and put is <tt class="docutils literal"><span class="pre">proc (bs: BitStream, input: tuple[&lt;fields&gt;])</span></tt>

</dd>
<a id="createVariantParser.m,untyped,untyped,untyped,varargs[untyped]"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#createVariantParser.m%2Cuntyped%2Cuntyped%2Cuntyped%2Cvarargs%5Buntyped%5D"><span class="Identifier">createVariantParser</span></a><span class="Other">(</span><span class="Identifier">name</span><span class="Other">,</span> <span class="Identifier">typ</span><span class="Other">,</span> <span class="Identifier">disc</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">rest</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">untyped</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

<p>This macro creates an object variant along with a variant parser (equivelant to a variant/sum type) for that type.</p>
<p>It takes the following mandatory arguments with must be first and in this order:</p>
<ul class="simple"><li>The name of the parser</li>
<li>The name of the variant type</li>
<li>The discriminator (<tt class="docutils literal"><span class="pre">&lt;name&gt;: &lt;type&gt;</span></tt>)</li>
</ul>
<p>And the following optional arguments:</p>
<ul class="simple"><li>Parser options (<tt class="docutils literal"><span class="pre">&lt;name&gt; = &lt;value&gt;</span></tt>)</li>
<li>Parameters (<tt class="docutils literal"><span class="pre">&lt;name&gt;: &lt;type&gt;</span></tt>)</li>
</ul>
<p>The body is similar to that of <tt class="docutils literal"><span class="pre">createParser</span></tt> macro, but the fields are partitioned in branches. Each branch starts with one or more possible value of the discriminator in parenthesis, seperated by comma.</p>
<p>For covering the rest of the cases use the <tt class="docutils literal"><span class="pre">_</span></tt> symbol (without parenthesis).</p>
<p>If you don't want a field for some branch, use <tt class="docutils literal"><span class="pre">nil</span></tt> on the right side.</p>
<p>For exporting a symbol, prefix it with <tt class="docutils literal"><span class="pre">*</span></tt> (this also work for the discriminator).</p>
<pre class="listing"><span class="Identifier">createVariantParser</span><span class="Punctuation">(</span><span class="Identifier">FooBar</span><span class="Punctuation">,</span> <span class="Identifier">FooBarTy</span><span class="Punctuation">,</span> <span class="Identifier">disc</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Operator">*</span><span class="Identifier">Foo</span><span class="Punctuation">:</span> <span class="Identifier">foo</span>
  <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">u32</span><span class="Punctuation">:</span> <span class="Operator">*</span><span class="Identifier">a</span>
  <span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">nil</span>
  <span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">u8</span><span class="Punctuation">:</span> <span class="Identifier">b</span>
    <span class="Operator">*</span><span class="Identifier">Bar</span><span class="Punctuation">:</span> <span class="Identifier">bar</span>
  <span class="Identifier">_</span><span class="Punctuation">:</span> <span class="Identifier">u32</span><span class="Punctuation">:</span> <span class="Identifier">abc</span></pre>

</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-03-18 23:25:53 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>

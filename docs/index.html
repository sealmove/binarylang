<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>binarylang</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">binarylang</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="dsl-invocation_toc" href="#dsl-invocation">DSL invocation</a></li>
<ul class="simple"><li><a class="reference" id="dsl-invocation-parser-options_toc" href="#dsl-invocation-parser-options">Parser options</a></li>
<li><a class="reference" id="dsl-invocation-parser-parameters_toc" href="#dsl-invocation-parser-parameters">Parser parameters</a></li>
</ul><li><a class="reference" id="types_toc" href="#types">Types</a></li>
<ul class="simple"><li><a class="reference" id="types-primitive-types_toc" href="#types-primitive-types">Primitive types</a></li>
<li><a class="reference" id="types-product-type_toc" href="#types-product-type">Product type</a></li>
<li><a class="reference" id="types-sum-type_toc" href="#types-sum-type">Sum type</a></li>
</ul><li><a class="reference" id="features_toc" href="#features">Features</a></li>
<ul class="simple"><li><a class="reference" id="features-alignment_toc" href="#features-alignment">Alignment</a></li>
<li><a class="reference" id="features-assertion_toc" href="#features-assertion">Assertion</a></li>
<li><a class="reference" id="features-repetition_toc" href="#features-repetition">Repetition</a></li>
<li><a class="reference" id="features-substreams_toc" href="#features-substreams">Substreams</a></li>
<li><a class="reference" id="features-strings_toc" href="#features-strings">Strings</a></li>
</ul><li><a class="reference" id="extensions_toc" href="#extensions">Extensions</a></li>
<ul class="simple"><li><a class="reference" id="extensions-custom-parser-api_toc" href="#extensions-custom-parser-api">Custom parser API</a></li>
<li><a class="reference" id="extensions-operations-experimental_toc" href="#extensions-operations-experimental">Operations <strong>(experimental)</strong></a></li>
</ul><li><a class="reference" id="special-notes_toc" href="#special-notes">Special notes</a></li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#MagicError"
    title="MagicError = object of Defect">MagicError</a></li>
  <li><a class="reference" href="#SyntaxError"
    title="SyntaxError = object of Defect">SyntaxError</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#17" id="67">Macros</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#typeGetter.m%2Ctyped"
    title="typeGetter(body: typed): untyped">typeGetter</a></li>
  <li><a class="reference" href="#struct.m%2Cuntyped%2Cvarargs%5Buntyped%5D"
    title="struct(name: untyped; rest: varargs[untyped]): untyped">struct</a></li>
  <li><a class="reference" href="#createParser.m%2Cuntyped%2Cvarargs%5Buntyped%5D"
    title="createParser(name: untyped; rest: varargs[untyped]): untyped">createParser</a></li>
  <li><a class="reference" href="#union.m%2Cuntyped%2Cuntyped%2Cvarargs%5Buntyped%5D"
    title="union(name, disc: untyped; rest: varargs[untyped]): untyped">union</a></li>
  <li><a class="reference" href="#createVariantParser.m%2Cuntyped%2Cuntyped%2Cvarargs%5Buntyped%5D"
    title="createVariantParser(name, disc: untyped; rest: varargs[untyped]): untyped">createVariantParser</a></li>

  </ul>
</li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc">
<h1><a class="toc-backref" id="dsl-invocation" href="#dsl-invocation">DSL invocation</a></h1><p>Two macros are exported:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">struct</span></tt> which is used to produce a <em>product parser</em></li>
<li><tt class="docutils literal"><span class="pre">union</span></tt> which is used to produce a <em>sum parser</em></li>
</ul>
<p>Both of these macros generate a type declaration and a <tt class="docutils literal"><span class="pre">tuple[get: proc, put: proc]</span></tt>:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">get</span></tt> returns an object with each parsed field</li>
<li><tt class="docutils literal"><span class="pre">put</span></tt> writes an object to a stream</li>
</ul>
<p>Each statement corresponds to 1 field. The general syntax is:</p>
<pre class="listing">type: name (...)</pre><p>For the name you use <tt class="docutils literal"><span class="pre">_</span></tt> to discard the field, or prepend it with <tt class="docutils literal"><span class="pre">*</span></tt> to export it.</p>

<h2><a class="toc-backref" id="dsl-invocation-parser-options" href="#dsl-invocation-parser-options">Parser options</a></h2><p>Each specified option must be in the form <tt class="docutils literal"><span class="pre">option = value</span></tt>:</p>
<ul class="simple"><li><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">endian</span></tt>: sets the default byte endianness for the whole parser</dt>
<dd><ul class="simple"><li><em>default</em>: big endian</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt>: <strong>big</strong> endian</li>
<li><tt class="docutils literal"><span class="pre">l</span></tt>: <strong>little</strong> endian</li>
<li><tt class="docutils literal"><span class="pre">c</span></tt>: <strong>cpu</strong> endian</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">bitEndian</span></tt>: sets the default bit endianness for the whole parser</dt>
<dd><ul class="simple"><li><em>default</em>: left -&gt; right</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt>: left -&gt; right (<strong>normal</strong>)</li>
<li><tt class="docutils literal"><span class="pre">r</span></tt>: left &lt;- right (<strong>reverse</strong>)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">reference</span></tt>: configures whether the associated type will be a <tt class="docutils literal"><span class="pre">ref</span></tt> or not</dt>
<dd><ul class="simple"><li><em>default</em>: no</li>
<li><tt class="docutils literal"><span class="pre">y</span></tt>: yes</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt>: no</li>
</ul>
</dd>
</dl>
</li>
</ul>

<h2><a class="toc-backref" id="dsl-invocation-parser-parameters" href="#dsl-invocation-parser-parameters">Parser parameters</a></h2><p>Each parameter must be in the form <tt class="docutils literal"><span class="pre">symbol: type</span></tt>. The generated <tt class="docutils literal"><span class="pre">get</span></tt>/<tt class="docutils literal"><span class="pre">put</span></tt> procs will then have this additional parameter appended.</p>
<p>The only exception is the discriminator field for <strong>sum</strong> parsers which is always named <tt class="docutils literal"><span class="pre">disc</span></tt> implicitly; and therefore, only the type must be provided -instead of an expression-colon-expression-.</p>

<h1><a class="toc-backref" id="types" href="#types">Types</a></h1>
<h2><a class="toc-backref" id="types-primitive-types" href="#types-primitive-types">Primitive types</a></h2><p>The <strong>kind</strong>, <strong>endianness</strong> and <strong>size</strong> are encoded in a identifier made up of:</p>
<ul class="simple"><li><dl class="docutils"><dt>1 optional letter specifying the kind:</dt>
<dd><ul class="simple"><li><em>default</em>: signed integer</li>
<li><tt class="docutils literal"><span class="pre">u</span></tt>: unsigned integer</li>
<li><tt class="docutils literal"><span class="pre">f</span></tt>: float</li>
<li><tt class="docutils literal"><span class="pre">s</span></tt>: string</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt>1 optional letter specifying byte endianness:</dt>
<dd><ul class="simple"><li><em>default</em>: big endian</li>
<li><tt class="docutils literal"><span class="pre">b</span></tt>: big endian</li>
<li><tt class="docutils literal"><span class="pre">l</span></tt>: little endian</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt>1 optional letter specifying bit endianness:</dt>
<dd><ul class="simple"><li><em>default</em>: left -&gt; right</li>
<li><tt class="docutils literal"><span class="pre">n</span></tt>: left -&gt; right (normal)</li>
<li><tt class="docutils literal"><span class="pre">r</span></tt>: left &lt;- right (reverse)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="docutils"><dt>1 number specifying size in <strong>bits</strong>:</dt>
<dd><ul class="simple"><li>for a string it refers to the size of each individual character and defaults to <tt class="docutils literal"><span class="pre">8</span></tt></li>
<li>for an integer the allowed values are <tt class="docutils literal"><span class="pre">1 .. 64</span></tt></li>
<li>for a float the allowed values are <tt class="docutils literal"><span class="pre">32</span></tt> and <tt class="docutils literal"><span class="pre">64</span></tt></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>You can order options however you want, but size must come last (e.g. <tt class="docutils literal"><span class="pre">lru16</span></tt> and <tt class="docutils literal"><span class="pre">url16</span></tt> are valid but not <tt class="docutils literal"><span class="pre">16lru</span></tt>).</p>
<p>Assertion can also be used in a special manner to terminate the previous field if it's a <strong>string</strong> or a <strong>sequence indicated as magic-terminated</strong>. This is discussed in later sections.</p>

<h2><a class="toc-backref" id="types-product-type" href="#types-product-type">Product type</a></h2><p>A parser is of type <strong>product</strong> if it is created with the <tt class="docutils literal"><span class="pre">struct</span></tt> macro or <em>by hand</em>, as explained in a later section. To call a product parser you must use <tt class="docutils literal"><span class="pre">*</span></tt> followed by the name of the parser. If your parser requires arguments, you must provide them using standard call syntax.</p>
<p>Example:</p>
<pre class="listing"><span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">inner</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">a</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">b</span>

<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">innerWithArgs</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">int32</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">a</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">]</span>

<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">outer</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Operator">*</span><span class="Identifier">inner</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="Operator">*</span><span class="Identifier">innerWithArgs</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">y</span></pre>
<h2><a class="toc-backref" id="types-sum-type" href="#types-sum-type">Sum type</a></h2><p>A parser is of type <strong>sum</strong> if it is created with the <tt class="docutils literal"><span class="pre">union</span></tt> macro or <em>by hand</em>, as explained in a later section. A sum parser has a special field called the <em>discriminator</em> which determines which branch will be activated at run-time -similarly to <em>object variants</em>-.</p>
<p>To call a sum parser you must use <tt class="docutils literal"><span class="pre">+</span></tt> followed by a call-syntaxed expression. The callee is the name of the parser and the first argument is the value of the <em>discriminator</em> field. If the parser requires additional arguments, they also have to be provided. The first argument is treated in a special manner. Unlike other arguments, this one is only evaluated during parsing, whereas during serialization the value stored in the <tt class="docutils literal"><span class="pre">disc</span></tt> field is used.</p>
<p>Example:</p>
<pre class="listing"><span class="Identifier">union</span><span class="Punctuation">(</span><span class="Identifier">inner</span><span class="Punctuation">,</span> <span class="Identifier">byte</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">a</span>
  <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="DecNumber">16</span><span class="Punctuation">:</span> <span class="Identifier">b</span>
  <span class="Identifier">_</span><span class="Punctuation">:</span> <span class="Keyword">nil</span>

<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">outer</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Operator">+</span><span class="Identifier">inner</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">x</span></pre>
<h1><a class="toc-backref" id="features" href="#features">Features</a></h1>
<h2><a class="toc-backref" id="features-alignment" href="#features-alignment">Alignment</a></h2><p>If any of the following is violated, BinaryLang should generate an exception:</p>
<ul class="simple"><li>Byte endianness can only be used with byte-multiple integers</li>
<li>Bit endianness must be uniform between <strong>byte boundaries</strong></li>
<li>Spec must finish on a byte boundary</li>
</ul>
<pre class="listing"><span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">parser</span><span class="Punctuation">,</span> <span class="Identifier">bitEndian</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">b9</span><span class="Punctuation">:</span> <span class="Identifier">a</span> <span class="Comment"># error: cannot apply byte endianness</span>
  <span class="Identifier">r6</span><span class="Punctuation">:</span> <span class="Identifier">b</span> <span class="Comment"># error: shares bits with previous byte</span>
  <span class="DecNumber">10</span><span class="Punctuation">:</span> <span class="Identifier">c</span> <span class="Comment"># error: spec does not finish on a byte boundary</span></pre><p>Moreover, unaligned reads for strings are not supported:</p>
<pre class="listing"><span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">parser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">6</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">y</span> <span class="Comment"># invalid, generates an exception</span></pre>
<h2><a class="toc-backref" id="features-assertion" href="#features-assertion">Assertion</a></h2><p>Use <tt class="docutils literal"><span class="pre">= expr</span></tt> for producing an exception if the parsed value doesn't match <tt class="docutils literal"><span class="pre">expr</span></tt>:</p>
<pre class="listing"><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;BinaryLang is awesome&quot;</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">]</span></pre>
<h2><a class="toc-backref" id="features-repetition" href="#features-repetition">Repetition</a></h2><p>There are 3 ways to produce a <tt class="docutils literal"><span class="pre">seq</span></tt> of your type:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">for</span></tt>: append <tt class="docutils literal"><span class="pre">[expr]</span></tt> to the name for repeating <tt class="docutils literal"><span class="pre">expr</span></tt> times</li>
<li><tt class="docutils literal"><span class="pre">until</span></tt>: append <tt class="docutils literal"><span class="pre">{expr}</span></tt> to the name for repeating until <tt class="docutils literal"><span class="pre">expr</span></tt> is evaluated to <tt class="docutils literal"><span class="pre">true</span></tt></li>
<li><tt class="docutils literal"><span class="pre">magic</span></tt>: enclose name with <tt class="docutils literal"><span class="pre">{}</span></tt> and use assertion with your <strong>next</strong> field</li>
</ul>
<pre class="listing"><span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Comment"># reads 5 8-bit integers</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">{</span><span class="Identifier">_</span> <span class="Operator">==</span> <span class="DecNumber">103</span> <span class="Keyword">or</span> <span class="Identifier">i</span> <span class="Operator">&gt;</span> <span class="DecNumber">9</span><span class="Punctuation">}</span> <span class="Comment"># reads until it finds the value 103 or</span>
                        <span class="Comment"># completes 10th iteration</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">c</span><span class="Punctuation">}</span> <span class="Comment"># reads 8-bit integers until next field is matches</span>
<span class="DecNumber">16</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="HexNumber">0xABCD</span>
<span class="Identifier">u8</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">d</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">}</span> <span class="Comment"># reads byte sequences each of length 5 until next field</span>
           <span class="Comment"># matches</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="StringLit">&quot;END&quot;</span></pre><p>Also, the following symbols are defined implicitly:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">i</span></tt>: current iteration index</li>
<li><tt class="docutils literal"><span class="pre">_</span></tt>: last element read</li>
</ul>
<p>These can be leveraged even in other expressions than the expression for repetition itself; for instance you can use them to parameterize a parser:</p>
<pre class="listing"><span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">inner</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">]</span>
<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">outer</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">amount</span>
  <span class="DecNumber">32</span><span class="Punctuation">:</span> <span class="Identifier">sizes</span><span class="Punctuation">[</span><span class="Identifier">amount</span><span class="Punctuation">]</span>
  <span class="Operator">*</span><span class="Identifier">inner</span><span class="Punctuation">(</span><span class="Identifier">sizes</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">aux</span><span class="Punctuation">[</span><span class="Identifier">amount</span><span class="Punctuation">]</span></pre><p>With the above trick you can get a sequence of variable-length sequences.</p>
<p>Due to current limitations of the underlying bitstream implementation, to perform magic, your stream must be aligned and all the reads involved must also be aligned. This will be fixed in the future.</p>

<h2><a class="toc-backref" id="features-substreams" href="#features-substreams">Substreams</a></h2><p>Call syntax forces the creation of a substream:</p>
<pre class="listing"><span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">aux</span><span class="Punctuation">,</span> <span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">]</span>
<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">parser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">limit</span> <span class="Operator">=</span> <span class="DecNumber">8</span>
  <span class="Operator">*</span><span class="Identifier">aux</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">fixed</span><span class="Punctuation">(</span><span class="Identifier">limit</span><span class="Punctuation">)</span></pre><p>In the above example, <tt class="docutils literal"><span class="pre">limit</span></tt> bytes (8 in this case) will be read from the main <tt class="docutils literal"><span class="pre">BitStream</span></tt>. Then, a substream will be created out of them, which will then be used as the stream for parsing <tt class="docutils literal"><span class="pre">fixed</span></tt>. Since <tt class="docutils literal"><span class="pre">fixed</span></tt> will only use 4 of them, the remaining 4 will effectively be discarded.</p>
<p>Note that unlike in the type, here size is counted in bytes. It is implied that you cannot create a substream if your bitstream is unaligned.</p>
<p>This feature is <strong>not implemented for repetition</strong> because it would increase complexity with little benefits. The following syntax is <strong>invalid</strong> and instead you should use the technique with the auxiliary parser shown above:</p>
<pre class="listing"><span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">parser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">u8</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># does substream refer to each individual element or the</span>
              <span class="Comment"># whole sequence?</span></pre>
<h2><a class="toc-backref" id="features-strings" href="#features-strings">Strings</a></h2><p>Strings are special because they don't have a fixed size. Therefore, you must provide enough information regarding their termination. This can be achieved with one of the following:</p>
<ul class="simple"><li>Use of substream</li>
<li>Assertion</li>
<li>Magic</li>
</ul>
<pre class="listing"><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">a</span> <span class="Comment"># null/eos-terminated (because next field doesn't use assertion)</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># reads a string from a substream of 5 bytes until null/eos</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="StringLit">&quot;ABC&quot;</span> <span class="Comment"># reads a string of length 3 that must match &quot;ABC&quot;</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">d</span> <span class="Comment"># reads a string until next field matches</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="StringLit">&quot;MAGIC&quot;</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">e</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Comment"># reads 5 null-terminated strings</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">f</span><span class="Punctuation">}</span> <span class="Comment"># reads null-terminated strings until next field matches</span>
<span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">term</span> <span class="Operator">=</span> <span class="HexNumber">0xff</span> <span class="Comment"># terminator of the above sequence</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">g</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">}</span> <span class="Comment"># sequence of 5-length sequences of null-terminated strings</span>
<span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">_</span> <span class="Operator">=</span> <span class="StringLit">&quot;END_NESTED&quot;</span></pre><p>Rules:</p>
<ul class="simple"><li>Strings are null/eos-terminated unless assertion is used on the same field <strong>or</strong> on the next field</li>
<li>When using repetition, each string element is null-terminated</li>
</ul>

<h1><a class="toc-backref" id="extensions" href="#extensions">Extensions</a></h1>
<h2><a class="toc-backref" id="extensions-custom-parser-api" href="#extensions-custom-parser-api">Custom parser API</a></h2><p>Since a BinaryLang parser is just a <tt class="docutils literal"><span class="pre">tuple[get: proc, put: proc]</span></tt>, you can write parsers by hand that are compatible with the DSL. Just be sure that <tt class="docutils literal"><span class="pre">get</span></tt> and <tt class="docutils literal"><span class="pre">put</span></tt> have proper signatures, and there is a type with the same name as your parser but capitalized:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Parser</span> <span class="Operator">=</span> <span class="Identifier">SomeType</span>
<span class="Keyword">proc</span> <span class="Identifier">get</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Parser</span>
<span class="Keyword">proc</span> <span class="Identifier">put</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Identifier">Parser</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">parser</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">get</span><span class="Punctuation">:</span> <span class="Identifier">get</span><span class="Punctuation">,</span> <span class="Identifier">put</span><span class="Punctuation">:</span> <span class="Identifier">put</span><span class="Punctuation">)</span></pre><p>If you want your custom parser to be parametric, simply append more parameters to your procs. These extra parameters must be identical and in the same order in the two procs:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Parser</span> <span class="Operator">=</span> <span class="Identifier">SomeType</span>
<span class="Keyword">proc</span> <span class="Identifier">get</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Parser</span>
<span class="Keyword">proc</span> <span class="Identifier">put</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Identifier">Parser</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">parser</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">get</span><span class="Punctuation">:</span> <span class="Identifier">get</span><span class="Punctuation">,</span> <span class="Identifier">put</span><span class="Punctuation">:</span> <span class="Identifier">put</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="extensions-operations-experimental" href="#extensions-operations-experimental">Operations <strong>(experimental)</strong></a></h2><p>Operations can be applied to fields with the following syntax:</p>
<pre class="listing">type {op(arg)}: name</pre><p>Operations act on data after the parsing and before the encoding respectively.</p>
<p>An operation is nothing more than a pair of templates which follow a specific pattern:</p>
<ul class="simple"><li>The names of the templates <strong>must</strong> follow the pattern: <tt class="docutils literal"><span class="pre">&lt;operation&gt;get</span></tt> and <tt class="docutils literal"><span class="pre">&lt;operation&gt;put</span></tt></li>
<li>They must have at least 3 untyped parameters (you can name them as you<dl class="docutils"><dt>wish):</dt>
<dd><ul class="simple"><li><strong>parameter #1</strong>: parsing/encoding statements</li>
<li><strong>parameter #2</strong>: variable <em>previously</em> parsed/encoded</li>
<li><strong>parameter #3</strong>: output</li>
</ul>
</dd>
</dl>
</li>
</ul>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">increaseGet</span><span class="Punctuation">(</span><span class="Identifier">parse</span><span class="Punctuation">,</span> <span class="Identifier">parsed</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parse</span>
  <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">parsed</span> <span class="Operator">+</span> <span class="Identifier">num</span>
<span class="Keyword">template</span> <span class="Identifier">increasePut</span><span class="Punctuation">(</span><span class="Identifier">encode</span><span class="Punctuation">,</span> <span class="Identifier">encoded</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">encoded</span> <span class="Operator">-</span> <span class="Identifier">num</span>
  <span class="Identifier">encode</span>
<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">64</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="DecNumber">16</span> <span class="Punctuation">{</span><span class="Identifier">increase</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">y</span></pre><p>You can apply more than one operations on one field, in which case they are chained in the specified order, and only the first operation really does any parsing/encoding to the stream. The rest just operate on the value produced by the operation directly before them.</p>
<p><tt class="docutils literal"><span class="pre">parse</span></tt> fills in the <tt class="docutils literal"><span class="pre">parsed</span></tt> variable. It is a seperate statement because it potentially operates on the stream (this happens <strong>always and only for the first operation</strong>). Similarly, <tt class="docutils literal"><span class="pre">encode</span></tt> passes on the value in <tt class="docutils literal"><span class="pre">output</span></tt> variable. <em>Passes</em> means the value is potentially written to the stream.</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">condGet</span><span class="Punctuation">(</span><span class="Identifier">parse</span><span class="Punctuation">,</span> <span class="Identifier">parsed</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">,</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Identifier">parse</span>
    <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">parsed</span>
<span class="Keyword">template</span> <span class="Identifier">condPut</span><span class="Punctuation">(</span><span class="Identifier">encode</span><span class="Punctuation">,</span> <span class="Identifier">encoded</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">,</span> <span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">encoded</span>
    <span class="Identifier">encode</span>
<span class="Keyword">template</span> <span class="Identifier">increaseGet</span><span class="Punctuation">(</span><span class="Identifier">parse</span><span class="Punctuation">,</span> <span class="Identifier">parsed</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parse</span>
  <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">parsed</span> <span class="Operator">+</span> <span class="Identifier">num</span>
<span class="Keyword">template</span> <span class="Identifier">increasePut</span><span class="Punctuation">(</span><span class="Identifier">encode</span><span class="Punctuation">,</span> <span class="Identifier">encoded</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">,</span> <span class="Identifier">num</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">encoded</span> <span class="Operator">-</span> <span class="Identifier">num</span>
  <span class="Identifier">encode</span>
<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">shouldParse</span>
  <span class="DecNumber">64</span><span class="Punctuation">:</span> <span class="Identifier">x</span>
  <span class="DecNumber">16</span> <span class="Punctuation">{</span><span class="Identifier">cond</span><span class="Punctuation">(</span><span class="Identifier">shouldParse</span><span class="Operator">.</span><span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">increase</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">y</span></pre><p>It is impossible for BinaryLang to infer the type of the altered value, that is, if your operation changes it. By default it is assumed that the new field value is of the same type as the <em>previous</em> one (for the first operation, this is the type produced according to the field type annotation). Therefore, if your operation alters the type, then you must provide the new type in square brackets:</p>
<pre class="listing"><span class="Keyword">template</span> <span class="Identifier">asciiNumGet</span><span class="Punctuation">(</span><span class="Identifier">parse</span><span class="Punctuation">,</span> <span class="Identifier">parsed</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parse</span>
  <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">char</span><span class="Punctuation">(</span><span class="Identifier">parsed</span> <span class="Operator">-</span> <span class="CharLit">'0'</span><span class="Punctuation">)</span>
<span class="Keyword">template</span> <span class="Identifier">asciiNumPut</span><span class="Punctuation">(</span><span class="Identifier">encode</span><span class="Punctuation">,</span> <span class="Identifier">encoded</span><span class="Punctuation">,</span> <span class="Identifier">output</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">output</span> <span class="Operator">=</span> <span class="Identifier">int8</span><span class="Punctuation">(</span><span class="Identifier">encoded</span> <span class="Operator">+</span> <span class="CharLit">'0'</span><span class="Punctuation">)</span>
  <span class="Identifier">encode</span>
<span class="Identifier">struct</span><span class="Punctuation">(</span><span class="Identifier">myParser</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="DecNumber">8</span> <span class="Punctuation">{</span><span class="Identifier">asciiNum</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">x</span></pre><p>The actual type of the field changes to the type annotated in the last operation. if you annotate the type for <em>some</em> of the operations, then for the ones you did not, the type of the operation directly previous to it is assumed.</p>

<h1><a class="toc-backref" id="special-notes" href="#special-notes">Special notes</a></h1><ul class="simple"><li><dl class="docutils"><dt>Nim expressions may contain:</dt>
<dd><ul class="simple"><li>a previously defined field</li>
<li>a parser parameter</li>
<li>the <tt class="docutils literal"><span class="pre">_</span></tt> symbol for <em>subject</em> element (its meaning varies)</li>
<li>the <tt class="docutils literal"><span class="pre">i</span></tt> symbol for current index in a repetition</li>
<li>the <tt class="docutils literal"><span class="pre">s</span></tt> symbol for accessing the bitstream</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p><tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">s</span></tt> might conflict with your variables or fields, so you should consider them reserved keywords and not use them for something else.</p>
</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<a id="MagicError"></a>
<dt><pre><a href="binarylang.html#MagicError"><span class="Identifier">MagicError</span></a> <span class="Other">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Defect</span></pre></dt>
<dd>



</dd>
<a id="SyntaxError"></a>
<dt><pre><a href="binarylang.html#SyntaxError"><span class="Identifier">SyntaxError</span></a> <span class="Other">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Defect</span></pre></dt>
<dd>



</dd>

</dl></div>
<div class="section" id="17">
<h1><a class="toc-backref" href="#17">Macros</a></h1>
<dl class="item">
<a id="typeGetter.m,typed"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#typeGetter.m%2Ctyped"><span class="Identifier">typeGetter</span></a><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">deprecated</span><span class="Other">:</span> <span class="StringLit">&quot;use type directly&quot;</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
  <div class="deprecation-message">
    <b>Deprecated:</b> use type directly
  </div>



</dd>
<a id="struct.m,untyped,varargs[untyped]"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#struct.m%2Cuntyped%2Cvarargs%5Buntyped%5D"><span class="Identifier">struct</span></a><span class="Other">(</span><span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">rest</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">untyped</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Input:<ul class="simple"><li><tt class="docutils literal"><span class="pre">name</span></tt>: Name of the parser tuple to create (must be lowercase)</li>
<li><tt class="docutils literal"><span class="pre">rest</span></tt>: <strong>Optional</strong> parser options and parameters</li>
<li><tt class="docutils literal"><span class="pre">rest</span></tt> (last): Block of the format described above</li>
</ul>
<p>Output:</p>
<ul class="simple"><li>Object type declaration with name <tt class="docutils literal"><span class="pre">tname</span></tt> ≡ <tt class="docutils literal"><span class="pre">capitalizeAscii(name)</span></tt></li>
<li>Reader proc that returns an object of the type <tt class="docutils literal"><span class="pre">tname</span></tt></li>
<li>Writer proc that accepts an object of type <tt class="docutils literal"><span class="pre">tname</span></tt></li>
<li>A tuple named <tt class="docutils literal"><span class="pre">name</span></tt> with the fields <tt class="docutils literal"><span class="pre">get</span></tt> and <tt class="docutils literal"><span class="pre">put</span></tt></li>
</ul>
<p>The procs are of the following form:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">get</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">tname</span><span class="Punctuation">`</span>
<span class="Keyword">proc</span> <span class="Identifier">put</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">tname</span><span class="Punctuation">`</span><span class="Punctuation">)</span></pre>

</dd>
<a id="createParser.m,untyped,varargs[untyped]"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#createParser.m%2Cuntyped%2Cvarargs%5Buntyped%5D"><span class="Identifier">createParser</span></a><span class="Other">(</span><span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">rest</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">untyped</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">deprecated</span><span class="Other">:</span> <span class="StringLit">&quot;renamed to \'struct\'&quot;</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
  <div class="deprecation-message">
    <b>Deprecated:</b> renamed to &apos;struct&apos;
  </div>



</dd>
<a id="union.m,untyped,untyped,varargs[untyped]"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#union.m%2Cuntyped%2Cuntyped%2Cvarargs%5Buntyped%5D"><span class="Identifier">union</span></a><span class="Other">(</span><span class="Identifier">name</span><span class="Other">,</span> <span class="Identifier">disc</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">rest</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">untyped</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Input:<ul class="simple"><li><tt class="docutils literal"><span class="pre">name</span></tt>: The name of the parser tuple to create (must be lowercase)</li>
<li><tt class="docutils literal"><span class="pre">disc</span></tt>: The definition of the discriminator field (<tt class="docutils literal"><span class="pre">name: type</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">rest</span></tt>: <strong>Optional</strong> parser options and parameters</li>
<li><tt class="docutils literal"><span class="pre">rest</span></tt> (last): Block of the format described above</li>
</ul>
<p>Output:</p>
<ul class="simple"><li><strong>Variant</strong> object type declaration with discriminator <tt class="docutils literal"><span class="pre">disc</span></tt> and name <tt class="docutils literal"><span class="pre">tname</span></tt> ≡ <tt class="docutils literal"><span class="pre">capitalizeAscii(name)</span></tt></li>
<li>Reader proc that returns an object of the type <tt class="docutils literal"><span class="pre">tname</span></tt></li>
<li>Writer proc that accepts an object of type <tt class="docutils literal"><span class="pre">tname</span></tt></li>
<li>A tuple named <tt class="docutils literal"><span class="pre">name</span></tt> with the fields <tt class="docutils literal"><span class="pre">get</span></tt> and <tt class="docutils literal"><span class="pre">put</span></tt></li>
</ul>
<p>The procs are of the following form:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">get</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">tname</span><span class="Punctuation">`</span>
<span class="Keyword">proc</span> <span class="Identifier">put</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">BitStream</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">tname</span><span class="Punctuation">`</span><span class="Punctuation">)</span></pre><p>The body is similar to that of <tt class="docutils literal"><span class="pre">struct</span></tt> macro, but the fields are partitioned in branches. Each branch starts with one or more possible value of the discriminator in parenthesis, seperated by comma.</p>
<p>For covering the rest of the cases use the <tt class="docutils literal"><span class="pre">_</span></tt> symbol (without parenthesis).</p>
<p>If you don't want a field for some branch, use <tt class="docutils literal"><span class="pre">nil</span></tt> on the right side.</p>
<p>Example:</p>
<pre class="listing"><span class="Identifier">union</span><span class="Punctuation">(</span><span class="Identifier">fooBar</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Operator">*</span><span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">a</span>
  <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">u32</span><span class="Punctuation">:</span> <span class="Operator">*</span><span class="Identifier">b</span>
  <span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">nil</span>
  <span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">u8</span><span class="Punctuation">:</span> <span class="Identifier">c</span>
    <span class="Operator">*</span><span class="Identifier">bar</span><span class="Punctuation">:</span> <span class="Identifier">d</span>
  <span class="Identifier">_</span><span class="Punctuation">:</span> <span class="Identifier">u32</span><span class="Punctuation">:</span> <span class="Identifier">e</span></pre>

</dd>
<a id="createVariantParser.m,untyped,untyped,varargs[untyped]"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#createVariantParser.m%2Cuntyped%2Cuntyped%2Cvarargs%5Buntyped%5D"><span class="Identifier">createVariantParser</span></a><span class="Other">(</span><span class="Identifier">name</span><span class="Other">,</span> <span class="Identifier">disc</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">rest</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">untyped</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">deprecated</span><span class="Other">:</span> <span class="StringLit">&quot;renamed to \'union\'&quot;</span></span><span class="Other">.}</span></span></pre></dt>
<dd>
  <div class="deprecation-message">
    <b>Deprecated:</b> renamed to &apos;union&apos;
  </div>



</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-08-22 22:56:31 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
